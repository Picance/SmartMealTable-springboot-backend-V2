# 📋 요구사항 명확화 문서 (Requirements Clarification Document)

**프로젝트:** 알뜰식탁 (SmartMealTable)  
**작성일:** 2025-10-08  
**버전:** v1.0

---

## 1. 개요

본 문서는 PRD, SRD, 추천시스템 문서, DDL 검토 후 발견된 모호한 부분에 대한 의사결정 내역을 정리한 문서입니다.  
SRS(Software Requirements Specification) 작성 시 참고자료로 활용됩니다.

---

## 2. 데이터 모델 관련 결정사항

### 2.1 추천 시스템 데이터

#### ✅ 결정사항

| 항목 | 기존 상태 | 해결 방법 |
|-----|---------|----------|
| **조회수 관리** | 누락 | `store.view_count` 컬럼 추가 (BIGINT, DEFAULT 0) |
| **최근 7일 조회수** | 누락 | `store_view_history` 테이블의 COUNT 쿼리로 처리 |
| **가게 등록일** | 누락 | 기존 `store.created_at` 컬럼 활용 (신규성 점수 계산용) |
| **사용자 조회 이력** | 누락 | `store_view_history` 테이블 추가 |
| **방문 이력** | 누락 | 기존 `expenditure` 테이블 활용 (마지막 방문일 추적) |

#### 📊 추가된 테이블: `store_view_history`

```sql
CREATE TABLE store_view_history (
    store_view_history_id BIGINT   NOT NULL AUTO_INCREMENT,
    member_id             BIGINT   NOT NULL COMMENT '조회한 회원 (논리 FK)',
    store_id              BIGINT   NOT NULL COMMENT '조회된 가게 (논리 FK)',
    viewed_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    -- 인덱스: idx_store_viewed_at (store_id, viewed_at)
);
```

**활용 목적:**
- 최근 7일 조회수: `SELECT COUNT(*) WHERE viewed_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)`
- 조회수 증가율 계산
- 추천 알고리즘의 "최근 관심도" 점수 계산

---

### 2.2 예산 관리 로직

#### ✅ 결정사항

```
1. 사용자는 먼저 일일 예산을 설정
2. 시스템은 (일일 예산 × 30 또는 31)을 월별 예산으로 제안
3. 사용자는 제안된 값을 수정할 수 있음
4. 일일 예산 수정 시 월별 예산은 자동으로 업데이트되지 않음
```

#### 📋 SRD 구체화 (REQ-PROFILE-204)

- **일일 예산 우선 설정**: 사용자가 아침/점심/저녁/기타 예산 입력
- **자동 계산**: `일일 총예산 = 아침 + 점심 + 저녁 + 기타`
- **월별 예산 제안**: `제안값 = 일일 총예산 × 해당 월의 일수`
- **사용자 선택**: 제안값 수락 또는 직접 입력
- **독립성**: 일일 예산과 월별 예산은 독립적으로 관리

---

### 2.3 소속(Group) 관리

#### ✅ 결정사항

| 항목 | 결정 내용 |
|-----|----------|
| **데이터 생성 주체** | 관리자만 생성 가능 (마스터 데이터) |
| **사용자 역할** | 검색 및 선택만 가능 |
| **검색 방법** | 자체 제공 API 사용 |
| **데이터 특성** | 사전 등록된 학교/회사 정보 |

#### 📌 구현 고려사항
- Admin 모듈에서 Group CRUD 기능 제공
- API 모듈에서는 Group 조회(검색) API만 제공
- 자동완성 기능을 위한 인덱스: `idx_name` (groups 테이블)

---

### 2.4 주소 관리

#### ✅ 결정사항

| 항목 | 결정 내용 |
|-----|----------|
| **저장 데이터** | GPS 좌표 + 주소 모두 저장 |
| **주소 검색 API** | 네이버 지도 API |
| **좌표 정밀도** | DECIMAL(9, 6) - 소수점 6자리 (약 0.1m 정밀도) |

#### 🗺️ address_history 테이블 구조
```sql
lot_number_address    VARCHAR(255) NULL      -- 지번 주소
street_name_address   VARCHAR(255) NOT NULL  -- 도로명 주소  
latitude              DECIMAL(9,6) NULL      -- 위도
longitude             DECIMAL(9,6) NULL      -- 경도
```

---

## 3. 기능 요구사항 관련 결정사항

### 3.1 지출 내역 파싱 (REQ-SPEND-411~415)

#### ✅ 결정사항

| 항목 | 결정 내용 |
|-----|----------|
| **지원 금융기관** | KB국민은행, NH농협은행, ... (레거시 프로젝트 재사용) |
| **파싱 엔진** | Spring AI - Gemini 라이브러리 활용 |
| **재사용 여부** | 이전 레거시 프로젝트 코드 그대로 사용 |

#### 📝 비고
- 파싱 로직은 SRS에서 상세히 다루지 않음
- 기존 검증된 코드 활용으로 개발 리스크 최소화

---

### 3.2 추천 시스템 초기 데이터 부족 (Cold Start)

#### ✅ 결정사항: **기본값 전략**

신규 사용자의 경우 아래 기본값을 적용:

| 추천 점수 요소 | Cold Start 전략 |
|-------------|----------------|
| **안정성 - 과거 지출** | 가중치를 0으로 설정, 선호 카테고리만 활용 |
| **탐험성 - 카테고리 신선도** | 모든 카테고리에 동일한 점수(50) 부여 |
| **탐험성 - 방문 기록** | 신규 가게 점수(100) 적용 |
| **예산 효율성** | 온보딩에서 설정한 예산 활용 |

#### 💡 더 나은 선택지 (향후 고려)
1. **인기 기반 추천**: 전체 사용자의 인기 가게 우선 추천
2. **같은 그룹 사용자 데이터 활용**: 같은 학교/회사 소속 사용자의 선호도 반영
3. **위치 기반 우선순위**: 사용자 주소 근처 가게 우선 추천

#### 📏 데이터 부족 기준
```
최근 6개월 지출 내역 < 3건 → Cold Start 사용자로 간주
```

---

### 3.3 주소 관리 (REQ-ONBOARD-203b)

#### ✅ 결정사항

| 항목 | 결정 내용 |
|-----|----------|
| **저장 방식** | GPS 좌표와 주소 둘 다 저장 |
| **주소 변환** | 네이버 지도 API - Geocoding |
| **API 선택** | 네이버 지도 API (주소 검색 + 좌표 변환) |

#### 🔄 처리 흐름
```
1. 사용자 "현재 위치로 찾기" 클릭
2. 브라우저에서 GPS 좌표 획득 (latitude, longitude)
3. 네이버 Reverse Geocoding API 호출 → 주소 변환
4. 지도 UI에 위치 마커 표시
5. 사용자 확인 후 저장
```

---

## 4. 비즈니스 로직 관련 결정사항

### 4.1 예산 초과 시나리오

#### ✅ 결정사항

| 시나리오 | 동작 |
|---------|-----|
| **예산 초과 시** | ⚠️ 경고 알림 발송 |
| **지출 등록 가능 여부** | ✅ 가능 (강제 제한 없음) |
| **예산 이월** | ❌ 다음 날로 이월되지 않음 |

#### 📱 알림 예시
```
"오늘 식비 예산 15,000원 중 17,000원을 사용하셨습니다. 
내일은 예산 내에서 식사해보세요! 💡"
```

---

### 4.2 즐겨찾기 vs 추천의 관계

#### ✅ 결정사항

| 항목 | 영향 여부 |
|-----|---------|
| **즐겨찾기 가산점** | ❌ 없음 |
| **즐겨찾기 순서** | ❌ 추천 알고리즘에 영향 없음 |

#### 💡 설계 의도
- 즐겨찾기: 사용자가 직접 관리하는 **북마크 기능**
- 추천: 알고리즘 기반 **새로운 발견 기능**
- 두 기능은 독립적으로 작동하여 각각의 가치 제공

---

### 4.3 영업시간 검증

#### ✅ 결정사항

| 항목 | 처리 방법 |
|-----|----------|
| **실시간 영업 상태** | 현재 시간과 `store_opening_hour` 비교 |
| **임시 휴무** | `store_temporary_closure` 테이블 조회, 해당 가게 필터링 |
| **휴게시간 없음** | `break_start_time`, `break_end_time` 모두 NULL |

#### 🕐 영업 상태 판단 로직
```java
// 의사코드
boolean isOpen = 
    (현재 시간 >= start_time && 현재 시간 < end_time)
    && !(현재 시간 >= break_start_time && 현재 시간 < break_end_time)
    && !existsTemporaryClosure(오늘 날짜);
```

#### 📊 새로 추가된 테이블: `store_temporary_closure`
```sql
CREATE TABLE store_temporary_closure (
    closure_start_date  DATE NOT NULL,
    closure_end_date    DATE NOT NULL,
    reason              VARCHAR(255) NULL,
    -- 인덱스: idx_closure_dates (store_id, closure_start_date, closure_end_date)
);
```

---

## 5. 추천 알고리즘 관련 결정사항

### 5.1 정규화 범위

#### ✅ 결정사항: **검색 결과 기준 정규화**

```
min, max는 현재 검색/필터링된 결과 집합 내에서 계산
```

#### 💡 이유
1. **성능**: 전체 가게 대상 집계는 비용이 높음
2. **공정성**: 같은 조건에서 비교할 때만 의미 있음
3. **실시간성**: 새 가게 추가 시 전체 재계산 불필요

#### 📐 정규화 공식
```java
// 검색 결과가 [r1, r2, ..., rn]일 때
min = MIN(r1, r2, ..., rn)
max = MAX(r1, r2, ..., rn)
normalized_score = 100 * (value - min) / (max - min)
```

---

### 5.2 시간 감쇠 함수 파라미터

#### ✅ 결정사항

| 파라미터 | 값 | 근거 |
|---------|---|------|
| **λ (람다)** | 0.01 | 약 100일 후 영향력 37%로 감소 |
| **기준일** | 지출 발생일 (expended_dt) | - |

#### 📊 감쇠 효과
```
w(t) = exp(-0.01 × t)

t=0일   → w = 1.00   (100%)
t=30일  → w = 0.74   (74%)
t=60일  → w = 0.55   (55%)
t=90일  → w = 0.41   (41%)
t=180일 → w = 0.17   (17%)
```

#### 💡 조정 가능성
- 초기 운영 후 사용자 피드백에 따라 λ 값 튜닝 가능
- 배치 작업으로 주기적으로 가중치 재계산

---

### 5.3 위치 기반 추천 범위

#### ✅ 결정사항: **필터 기반 동적 범위**

사용자가 직접 선택하는 필터 제공:

| 필터 옵션 | 반경 | 기본값 |
|---------|-----|--------|
| 0.5km 미만 | 500m | ✅ (기본값) |
| 1km 미만 | 1000m | - |
| 2km 미만 | 2000m | - |

#### 📍 위치 정보 우선순위
```
1. 현재 GPS 위치 (실시간)
2. 등록된 주소 중 기본 주소 (is_primary = true)
3. 등록된 주소 중 가장 최근 주소
```

#### 🗺️ 거리 계산: Haversine 공식
```java
// 의사코드
double distance = calculateHaversineDistance(
    userLat, userLng, 
    storeLat, storeLng
);
```

---

### 5.4 추천 결과 필터 및 정렬

#### ✅ 결정사항: **상세 필터 옵션**

#### (1) 필터

| 필터 항목 | 옵션 | 기본값 |
|---------|------|--------|
| **반경 거리** | 0.5km / 1km / 2km | 0.5km |
| **불호 음식** | 포함 / 제외 | 포함 |
| **영업 시간** | 전체 / 영업 중만 | 전체 |
| **학식/음식점** | 전체 / 학식만 / 음식점만 | 전체 |

#### (2) 정렬 조건

| 정렬 기준 | 설명 |
|---------|------|
| **기본 순** | 추천 점수 내림차순 (알고리즘) |
| **가까운 순** | 거리 오름차순 |
| **리뷰 순** | review_count 내림차순 |
| **평균 가격 낮은 순** | average_price 오름차순 |
| **평균 가격 높은 순** | average_price 내림차순 |
| **즐겨찾기 많은 순** | favorite 테이블 COUNT 내림차순 |
| **관심도 높은 순** | view_count 내림차순 |
| **관심도 낮은 순** | view_count 오름차순 |

---

## 6. 기술 스택 관련 결정사항

### 6.1 외부 API 의존성

#### ✅ 결정사항

| 용도 | 선택된 서비스 | 비고 |
|-----|-------------|------|
| **지도 표시** | 네이버 지도 API | - |
| **주소 검색** | 네이버 지도 Geocoding API | - |
| **결제 문자 파싱** | Spring AI - Gemini | 레거시 재사용 |

#### 🔑 필요한 API 키
- 네이버 지도 API Client ID, Secret
- Google Gemini API Key

---

### 6.2 배치 작업 범위

#### ✅ 결정사항: **필요 배치 작업**

| 배치 작업명 | 실행 주기 | 목적 |
|-----------|---------|------|
| **조회수 집계** | 매일 자정 | `store.view_count` 업데이트 |
| **만료 토큰 정리** | 매일 새벽 3시 | `social_account` expired 토큰 삭제 |
| **탈퇴 회원 데이터 삭제** | 매일 새벽 4시 | 탈퇴 후 1년 경과 데이터 영구 삭제 |
| **예산 초과 알림** | 매일 저녁 9시 | 당일 예산 초과 사용자에게 푸시 알림 |
| **비밀번호 만료 알림** | 매일 오전 9시 | 만료 7일 전 사용자에게 알림 |

#### 📦 Batch 모듈 구조
```
smartmealtable-batch/
  ├── crawler/         # 레거시 크롤러
  ├── statistics/      # 신규: 통계 집계
  └── notification/    # 신규: 알림 발송
```

---

## 7. 보안 및 정책 관련 결정사항

### 7.1 지출 내역 수정/삭제

#### ✅ 결정사항: **허용**

- 사용자가 실수로 잘못 입력한 경우를 위해 수정/삭제 기능 제공
- Soft Delete 방식 사용 (deleted_at 컬럼)
- 삭제 시 추천 알고리즘에서 제외

---

### 7.2 소셜 계정 중복 연동

#### ✅ 결정사항: **이메일 기준 허용**

```
같은 이메일이라면 여러 소셜 계정(카카오, 구글) 연동 가능
```

#### 📋 시나리오 예시
```
user@example.com 이메일을 가진 사용자:
- 카카오 계정 연동 ✅
- 구글 계정 연동 ✅
→ 두 소셜 계정 모두로 로그인 가능
```

---

### 7.3 비밀번호 변경 주기

#### ✅ 결정사항

| 항목 | 값 |
|-----|---|
| **변경 주기** | 90일 |
| **스킵 가능 여부** | ✅ 가능 |
| **스킵 시 연장** | +90일 |

#### 🔐 구현 로직
```java
// 의사코드
if (password_expires_at < NOW()) {
    showPasswordChangeModal();
    
    if (userClicksSkip()) {
        password_expires_at = NOW() + 90 DAYS;
    } else if (userChangesPassword()) {
        password_expires_at = NOW() + 90 DAYS;
        password_changed_at = NOW();
    }
}
```

---

### 7.4 탈퇴 회원 데이터 보관 기간

#### ✅ 결정사항: **1년**

| 항목 | 세부사항 |
|-----|---------|
| **보관 기간** | 탈퇴 후 1년 (365일) |
| **삭제 방식** | Soft Delete → Hard Delete |
| **보관 대상** | 법적 보관 의무 없는 모든 개인정보 |

#### 🗑️ 삭제 프로세스
```
1. 탈퇴 요청 시: deleted_at = NOW()
2. 365일 경과 후: Batch 작업으로 영구 삭제
3. 삭제 대상: expenditure, preference, favorite, address_history 등
4. 보관 대상: 법적 의무 데이터 (주문 내역 등)
```

---

### 7.5 멀티 디바이스 지원

#### ✅ 결정사항: **허용**

- JWT 토큰 기반 인증
- 동시 여러 기기에서 로그인 가능
- 각 디바이스는 독립적인 토큰 보유

---

## 8. DDL 최종 변경사항 요약

### 8.1 추가된 테이블

| 테이블명 | 목적 |
|---------|------|
| `store_view_history` | 가게 조회 이력 (추천 알고리즘용) |
| `store_temporary_closure` | 임시 휴무 정보 |

### 8.2 추가/수정된 컬럼

| 테이블 | 컬럼 | 타입 | 설명 |
|-------|-----|------|------|
| `store` | `view_count` | BIGINT | 총 조회수 (추천 알고리즘용) |
| `store` | `created_at` | DATETIME | 가게 등록일 (기존 활용) |
| `member_authentication` | `password_changed_at` | DATETIME | 마지막 비밀번호 변경 시각 |
| `member_authentication` | `password_expires_at` | DATETIME | 비밀번호 만료 시각 (90일) |
| `member_authentication` | `deleted_at` | DATETIME | 회원 탈퇴 시각 |
| `preference` | `weight` | SMALLINT | 100(좋아요), 0(보통), -100(싫어요) |

### 8.3 추가된 인덱스

```sql
-- store 테이블
INDEX idx_view_count (view_count)
INDEX idx_created_at (created_at)

-- store_view_history 테이블
INDEX idx_store_viewed_at (store_id, viewed_at)

-- member_authentication 테이블
INDEX idx_deleted_at (deleted_at)
```

---

## 9. SRS 작성 시 우선순위

### 🔴 High Priority (필수)
1. 추천 알고리즘 상세 명세
2. API 스펙 (엔드포인트, Request/Response)
3. 에러 코드 정의
4. 데이터베이스 ERD

### 🟡 Medium Priority (중요)
1. 배치 작업 상세 스펙
2. 외부 API 연동 방법
3. 인증/인가 플로우

### 🟢 Low Priority (참고)
1. UI/UX 가이드라인
2. 성능 튜닝 전략
3. 모니터링 지표

---

## 10. 추가 고려사항

### 10.1 추천 알고리즘 개선 방향 (v2.0)

1. **A/B 테스트**: 여러 추천 전략 비교
2. **머신러닝 도입**: 사용자 행동 패턴 학습
3. **협업 필터링**: 비슷한 취향 사용자 데이터 활용
4. **컨텍스트 인식**: 날씨, 요일, 시간대 고려

### 10.2 확장성 고려사항

1. **Redis 캐싱**: 추천 결과, 가게 정보 캐싱
2. **Read Replica**: 조회 성능 개선
3. **Elasticsearch**: 가게 검색 성능 개선
4. **CDN**: 이미지 로딩 속도 개선

---

## 11. 문서 변경 이력

| 버전 | 날짜 | 변경 내용 | 작성자 |
|-----|------|----------|--------|
| 1.0 | 2025-10-08 | 초안 작성 | - |

---

**본 문서는 PRD, SRD, 추천시스템 요구사항 문서, DDL을 기반으로 작성되었습니다.**
